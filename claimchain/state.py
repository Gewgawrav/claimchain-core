import json
import os
import warnings

import attr
import hippiepug as pug

from time import time
from collections import defaultdict

from .core import get_capability_lookup_key
from .core import encode_capability, decode_capability
from .core import encode_claim, decode_claim
from .core import _compute_claim_key

from .utils import bytes2ascii, ascii2bytes, pet2ascii, ascii2pet
from .utils import profiled
from .utils import cached_property

from .crypto import PublicParams, LocalParams
from .crypto import sign, verify_signature


PROTOCOL_VERSION = 2


@attr.s
class Metadata(object):
    """Claimchain block metadata."""
    params = attr.ib()
    identity_info = attr.ib(default=None)


@attr.s
class Payload(object):
    """Claimchain block payload."""

    mtr_hash  = attr.ib()
    metadata  = attr.ib()
    nonce     = attr.ib(default=False)
    timestamp = attr.ib(default=attr.Factory(lambda: time()))
    version   = attr.ib(default=PROTOCOL_VERSION)

    @staticmethod
    def build(mtr_hash, nonce, identity_info=None):
        """Build a payload.

        :param str mtr_hash: ASCII-encoded MTR hash
        :param bytes nonce: A bunch of randomly generated bytes
        :param str identity_info: Owner's public info
        """
        metadata = Metadata(
                params=LocalParams.get_default().public_export(),
                identity_info=identity_info)
        return Payload(metadata=metadata,
                       mtr_hash=mtr_hash,
                       nonce=bytes2ascii(nonce))

    @staticmethod
    def from_dict(exported):
        """Load payload from dictionary-exported form."""
        raw_metadata = exported["metadata"]
        raw_payload = dict(exported)
        raw_payload['metadata'] = Metadata(**raw_metadata)
        return Payload(**raw_payload)

    def to_dict(self):
        """Export to dictionary."""
        return asdict(self)

    def to_bytes(self):
        """Export to bytes using json."""
        return json.dumps(self.payload.export(), sort_keys=True)


class SignedBlockBuilder(pug.chain.BlockBuilder):
    def pre_commit(self):
        """Sign the payload before committing."""
        # Convert payload to JSON-dumped string for signing.
        payload_hash = self.object_store.hash_object(payload.to_bytes())
        sig = self.sign(self.payload)

        # Substitute payload with tuple raw payload and signature
        self.payload = (self.payload.as_dict(), pet2ascii(sig))


class ClaimchainBuilder(object):
    def __init__(self, current_claimchain):
        self.current_claimchain = current_claimchain
        self.identity_info = None

        self._claim_content_by_label = {}
        self._caps_by_reader_pk = defaultdict(set)
        self._vrf_value_by_label = {}
        self._payload = None
        self._chain = None
        self._tree = None

    @property
    def tree(self):
        try:
            return self._tree
        except AttributeError:
            raise ValueError('Tree is not committed yet.')

    @property
    def chain(self):
        try:
            return self._chain
        except AttributeError:
            raise ValueError('Chain is not committed yet.')

    def commit(self, nonce=None):
        """Commit the state to a claimchain."""

        if self.current_claimchain.tree_store is None:
            tree_store = chain_store
        if nonce is None:
            nonce = os.urandom(PublicParams.get_default().nonce_size)
        self._nonce = nonce

        block_builder = SignedBlockBuilder(chain_store)
        tree_builder = TreeBuilder(tree_store)

        # Encode claims.
        vrf_value_by_label = {}
        for claim_label, claim_content in self._claim_content_by_label.items():
            vrf_value, lookup_key, enc_claim = encode_claim(
                    nonce, claim_label, claim_content)
            tree_builder[lookup_key] = enc_claim
            vrf_value_by_label[claim_label] = vrf_value

        # Encode capabilities.
        for reader_dh_pk, caps in self._caps_by_reader_pk.items():
            for claim_label in caps:
                try:
                    vrf_value = vrf_value_by_label[claim_label]
                except KeyError:
                    warnings.warn("VRF for %s not computed. "
                                  "Skipping adding a capability." \
                                  % claim_label)
                    break
                lookup_key, enc_cap = encode_capability(
                        reader_dh_pk, nonce, claim_label, vrf_value)
                tree_builder[lookup_key] = enc_cap

        self._vrf_value_by_label = vrf_value_by_label

        # Put all the encrypted items in a new tree.
        self._tree = tree_builder.commit()

        # Put the payload in the chain.
        self._payload = block_builder.payload = Payload.build(
                mtr_hash=self.tree.root,
                nonce=nonce,
                identity_info=self.identity_info)
        self._chain = block_builder.commit()

        return self.chain.head

    def compute_evidence_keys(self, reader_dh_pk, claim_label):
        try:
            vrf_value = self._vrf_value_by_label[claim_label]
            cap_lookup_key = get_capability_lookup_key(
                    reader_dh_pk, self._nonce, claim_label)

            # Compute capability entry evidence
            _, raw_cap_evidence = self.tree.evidence(cap_lookup_key)
            claim_lookup_key = _compute_claim_key(vrf_value, mode='lookup')

            # Compute claim evidence
            _, raw_claim_evidence = self.tree.evidence(claim_lookup_key)
            object_keys = {obj.hid for obj in raw_cap_evidence} | \
                          {obj.hid for obj in raw_claim_evidence}

            # Add encoded capability and encoded claim value
            encoded_cap_hash = raw_cap_evidence[-1].item
            encoded_claim_hash = raw_claim_evidence[-1].item
            return object_keys | {encoded_claim_hash} | {encoded_cap_hash}

        except KeyError:
            return set()

    def clear(self):
        self._claim_content_by_label.clear()
        self._caps_by_reader_pk.clear()

        self._enc_items_map.clear()
        self._vrf_value_by_label.clear()
        self._payload = None
        self._tree = None

    def __getitem__(self, label):
        return self._claim_content_by_label[label]

    def __setitem__(self, claim_label, claim_content):
        self._claim_content_by_label[claim_label] = claim_content

    def grant_access(self, reader_dh_pk, claim_labels):
        self._caps_by_reader_pk[reader_dh_pk].update(set(claim_labels))

    def revoke_access(self, reader_dh_pk, claim_labels):
        self._caps_by_reader_pk[reader_dh_pk].difference_update(claim_labels)

    def get_capabilities(self, reader_dh_pk):
        return list(self._caps_by_reader_pk[reader_dh_pk])


class Claimchain(object):
    @staticmethod
    def from_store(chain_store, head, tree_store=None):
        """
        Build a claimchain from given stores.

        :param chain_store: Store where the chain blocks can be found
        :type chain_store: :py:mod:`hippiepug.store.ObjectStore`
        :param head: Chain head
        :param tree_store: Store where tree tree nodes can be found
        """
        self._chain = pug.chain.Chain(chain_store, head)
        if tree_store is None:
            tree_store = chain_store
        self._tree_store = tree_store

    def __init__(self, chain, tree=None):
        self._chain = chain
        if tree is None:
            self._tree_store = self._chain.object_store
        else:
            self._tree = tree

    @property
    def head(self):
        """Hash of the latest block of the chain."""
        return self.chain.head

    @property
    def chain(self):
        """Underlying chain view."""
        return self._chain

    @property
    def tree(self):
        """View of the tree in the latest chain block."""
        if self._tree is not None:
            return self._tree
        else:
            if self.payload.mtr_hash is not None:
                self._tree = pug.tree.Tree(
                        object_store=self._tree_store,
                        root=self.payload.mtr_hash)
            return self._tree

    @cached_property
    def payload(self):
        """Parsed payload of the latest block."""
        payload, sig = self.chain.head_block.payload
        return Payload.from_dict(self.chain.payload)

    @cached_property
    def params(self):
        """Local cryptographic params."""
        return LocalParams.from_dict(self.payload.metadata.params)

    # TODO: This validation is incorrect for any block but the genesis
    # def validate(self):
    #     owner_sig_pk = self.params.sig.pk
    #     raw_sig_backup = self._latest_block.aux
    #     sig = ascii2pet(raw_sig_backup)
    #     self._latest_block.aux = None
    #     if not verify_signature(owner_sig_pk, sig, self._latest_block.hash()):
    #         self._latest_block.aux = raw_sig_backup
    #         raise ValueError("Invalid signature.")
    #     self._latest_block.aux = raw_sig_backup

    def _lookup_capability(self, claim_label):
        cap_lookup_key = get_capability_lookup_key(
                self.params.dh.pk, self._nonce, claim_label)
        try:
            cap = self.tree[cap_lookup_key]
        except KeyError:
            raise KeyError("Label does not exist or you don't have "
                           "permission to read.")
        except AttributeError:
            raise ValueError("The chain does not have a claim map.")
        return decode_capability(self.params.dh.pk, self._nonce,
                                 claim_label, cap)

    def _lookup_claim(self, claim_label, vrf_value, claim_lookup_key):
        try:
            enc_claim = self.tree[claim_lookup_key]
        except KeyError:
            raise KeyError("Claim not found, but permission to read the label "
                           "exists.")
        except AttributeError:
            raise ValueError("The chain does not have a claim map.")
        return decode_claim(self.params.vrf.pk, self._nonce,
                            claim_label, vrf_value, enc_claim)

    def __getitem__(self, claim_label):
        vrf_value, claim_lookup_key = self._lookup_capability(claim_label)
        claim = self._lookup_claim(claim_label, vrf_value, claim_lookup_key)
        return claim

    def get(self, claim_label):
        try:
            return self[claim_label]
        except KeyError:
            return None
        except ValueError:
            return None

    def __hash__(self):
        return hash(self.head)
